(provide 'sjt-vm-addons)

(require 'rfc5234-core)

;;; VM MIME body extraction

;; VM's MIME handling is quite convoluted.  It involves MIME "layouts" and
;; several functions coded to be fast but loose.  The following documents
;; the behavior of vm-mime.el and vm-rfaddons.el.
;;
;; Let's follow #'vm-mime-save-all-attachments all the way down to saving
;; a file.
;; #'vm-mime-save-all-attachments is defined in vm-rfaddons.el.  It calls
;; #'vm-mime-action-on-all-attachments with an ACTION with arguments
;; (MSG LAYOUT TYPE FILE).  MSG may affect the directory for saving
;; attachments.  ACTION passes LAYOUT and FILE to #'vm-mime-send-body-to-file
;; and optionally to #'vm-mime-discard-layout-contents.  TYPE is used in
;; prompts.  FILE is the file name to save to.  #'vm-mime-send-body-to-file
;; takes the file name from FILE or fetches it from LAYOUT (this duplicates
;; behavior in ACTION).  All of this is pretty literal; the relevant parsing
;; is done when LAYOUT is created.  #'vm-mime-action-on-all-attachments just
;; fetches LAYOUT from the current message using #'vm-mm-layout-parts or
;; #'vm-mm-layout.
;; Layouts are generated by #'vm-mime-parse-entity (and "fake" layouts are
;; generated by several error handlers), defined in vm-mime.el.
;; MIME Content-Type and Content-Disposition fields are parsed by
;; #'vm-mime-parse-content-header (fset to #'vm-parse-structured-header).
;; #'vm-parse-structured-header is defined in vm-misc.el.  This function
;; returns a list of parameters, which may be tokens or token=value
;; combinations as strings.
;; The filename is parsed by #'vm-mime-get-disposition-parameter, which
;; delegates to #'vm-mime-get-disposition-parameter, which in turn delegates
;; to #'vm-mime-get-xxx-parameter, which does RFC 2047 processing and RFC
;; 2184 continuation processing but not RFC 2184 charset and language
;; processing.

;;; End-user utilities (not just VM)

(defun sjt/find-quoted-hex (&optional quote-chars)
  "Search forward from point for quoted hex code.

Optional QUOTE-CHARS is a string containing characters that are recognized
as hex-quoting characters, \"=%\" by default."
  (interactive "i")
  (re-search-forward (concat ?[ (or quote-chars "%=") ?] "[0-9A-Fa-f]\{2\}")))


(defun sjt/replace-quoted-hex-with-bytes (start end-marker &optional buffer)
  "Replace quoted hex with bytes in region.

The character at START is taken as the quote character.  Replaces until end
of region or parsing fails.
BUG: The quote character is deleted before the parsing of the hex code, and
not replaced if the parse fails."
  (interactive "r")
  (save-excursion
    (goto-char start buffer)
    ;; Handle both MIME quoted-printable (?= quoted) and RFC 2231 and
    ;; URL-escaped (?%-quoted) encodings.
    ;; #### Assumes first character (at point) is quote character.
    ;; #### Currently stops if it finds an unescaped character.
    (let ((quote-char (char-after)))
      (while (and (= (char-after) quote-char)
		  (< (point) end-marker))
	(delete-char 1)
	(insert (int-to-char
		 (string-to-number (buffer-substring (point) (+ (point) 2))
				   16)))
	(delete-char 2)))))

;;; Mail header parsing

;; The basic strategy is to use the mail folder buffer itself.  This may not
;; work terribly well with VM since it likes to mess with restrictions and
;; such, but we'll give it a try.
;; - The lowest level of parsing is simply character classes and regexps.
;; - The next level are functions which return tokens, including comments and
;;   quotations.  The return value is a pair of positions (START END) in the
;;   folder buffer, or nil if the element is not present.
;;   #### Perhaps this should error if required?
;;   I'm not sure what dotted atoms are.  I think in RFC 5322 they are
;;   tokens, but in RFC 822 they were sequences of tokens, and could have
;;   CFWS embedded in them.
;; - At the top level, functions parse field bodies.  I considered parsing
;;   the whole field from name to body, but it seems clearer to extract the
;;   field name and dispatch on it, rather than try to parse each field type
;;   at each field.
;; - Each element parsing function expects to be positioned at a candidate
;;   for that element.  Each parsing function should consume following
;;   whitespace.  (#### Not yet implemented.)  Parsing functions are those
;;   named 'parse' or 'require'.

;;; RFC 5322 lexical tokens
;;
;; Parenthesization and content extraction is left to calling code.

;; #### Do we need the *-re versions?
;; #### We should optimize by leaving out the return values for non-tokens.

;; Mly's rfc822.el uses regexps a lot more, and probably is faster for that.

;; RFC 5322 utility classes

(defconst rfc5322-quoted-pair-re
  (concat #r"\\[" rfc5234-vchar rfc5234-wsp "]")
  "Match one RFC 5322 quoted pair.")

(defsubst rfc5322-parse-quoted-pair ()
  "Parse one RFC 5322 quoted pair."
  (when (looking-at rfc5322-quoted-pair-re)
    (forward-char 2)
    (list (- (point) 2) (point))))	; for rfc5322-skip-qcontent

;; These two defconsts aren't real RFC 5322 ABNF.
(defconst rfc5322-vchars-re (concat "[" rfc5234-vchar "]+"))
(defconst rfc5322-wschars-re (concat rfc5234-wsp-re "+"))

(defconst rfc5322-specials #r"].()<>@,;:\\\"[")
(defconst rfc5322-specials-re (concat "[" rfc5322-specials "]"))

;; RFC 5322 whitespace and comments
;; These are classed together because comments are semantic nulls in
;; RFC 5322 processing.  Higher levels never see them.

;; Don't use rfc5234 LWS.
(defconst rfc5322-fws-re
  (concat "\\(?:" rfc5234-wsp-re "*" rfc5234-crlf-re "\\)?"
	  rfc5234-wsp-re "+")
  "Match RFC 5322 folded whitespace.")	; #### or with obs-fws

(defsubst rfc5322-parse-fws ()
  "Parse RFC 5322 folding whitespace.

This definition tries to prevent blank lines itself, but care should be
taken to avoid repetition of this expression when parsing."
  (when (looking-at rfc5322-fws-re)
    (let ((start (point)))
      (goto-char (match-end 0))
      (list start (point)))))

(defconst rfc5322-ctext-re "[]!-'*-[^-~]"
  "Match RFC 5322 ctext.")

(defsubst rfc5322-parse-ctext ()
  "Parse one RFC 5322 ctext character."
  (when (looking-at rfc5322-ctext-re)
    (forward-char 1)
    (list (1- (point)) (point))))

;; #### I think this is an accurate translation of the ABNF.
;; However, it is unclear what is to be done with an unclosed open parenthesis
;; followed by a comment.  This code parses as an open parenthesis, followed
;; by an optional run of ctext, followed by a comment.  Perhaps it would be
;; better to parse the *inner* open parenthesis as unclosed.  That would be
;; much more complicated to implement, though.
(defsubst rfc5322-parse-ccontent ()
  "Parse RFC 5322 ccontent and position point at end."
  (cond ((rfc5322-parse-quoted-pair))
	((looking-at rfc5322-ctext-re) (forward-char 1))
	((char= ?\( (char-after)) (rfc5322-parse-comment))))

;; #### Mutually recursive with #'rfc5322-parse-ccontent.  Both can't
;; be defsubsts.  Need to rewrite counting parens.
(defun rfc5322-parse-comment ()
  "Parse RFC 5322 comment, position point at end, and return (START END).

If not looking-at \"(\" when called, return nil.
If the opening parenthesis is not matched, move past the parenthesis,
returning (START (1+ START))."
  (when (char= ?\( (char-after))
    (let ((start (point)))
      (forward-char 1)
      (while (or (rfc5322-parse-fws) (rfc5322-parse-ccontent)))
      (if (char= ?\) (char-after))
	  (forward-char 1)
	(goto-char (1+ start)))
      (prog1 (list start (point))
	(rfc5322-parse-fws)))))

(defsubst rfc5322-parse-cfws ()
  "Match RFC 5322 CFWS, position point at end, and return (START END)."
  (let ((start (point)))
    (while (or (rfc5322-parse-fws) (rfc5322-parse-comment)))
    (when (not (= start (point)))	; If not moved, return nil.
      (list start (point)))))

;; RFC 5322 atoms

(defconst rfc5322-atext-re
  (concat "[" rfc5234-alpha rfc5234-digit "!#$%&'*+-/=_^_`{|}~" "]+")
  "This is a non-empty sequence of atext as defined in RFC 5322.")

(defsubst rfc5322-parse-atom ()
  "Parse RFC 5322 atom.  Returns (START END) for the atom only.

Point may be past END.  Original point is forgotten."
  (let ((start (point)) end)
    (cond ((looking-at rfc5322-atext-re)
	   (setq start (point))
	   (goto-char (match-end 0))
	   (setq end (point))
	   (rfc5322-parse-cfws)
	   (list start end))
	  (t (goto-char start)
	     nil))))

(defsubst rfc5322-parse-dot-atom ()
  "Parse RFC 5322 dot atom.  Returned (START END) bounds the atom.

If the parse fails (no atom), resets point to original position.
This does not permit CFWS within the dot-atom.
RFC 822 doesn't define this element and doesn't explicitly allow CFWS, but
the examples regularly include it.  RFC 2822 defines it the same way, and
in addresses obsoletes CFWS.
Point may be past END.  Original point is forgotten."
  (let ((origin (point)) start end)
    (if (and (looking-at rfc5322-atext-re)
	     (setq start (point))
	     (goto-char (match-end 0))
	     (setq end (point))
	     (while (and (char= ?\. (char-after))
			 ;; #### This probably signals at end-of-buffer.
			 (progn (forward-char 1) t)
			 (looking-at rfc5322-atext-re)
			 (goto-char (match-end 0))
			 (setq end (point))))
	     (= end (point)))
	(progn
	  (rfc5322-parse-cfws)
	  (list start end))
      (goto-char origin)
      nil)))

;; RFC 5322 quoted strings

(defconst rfc5322-qtext-re "[\x21\x23-\x5B\x5D-\x7E]+")

;; #### Make the parse/skip nomenclature consistent.  Document it.
;; Maybe we don't need it?  This function needs to return status.
(defsubst rfc5322-parse-qcontent ()
  "Somewhat more aggressive than RFC 5322 definition."
  (let ((origin (point))		; use 'origin for if-moved
	end)
    (while (or (when (looking-at rfc5322-qtext-re)
		 (goto-char (match-end 0)))
	       (rfc5322-parse-quoted-pair)))
    (setq end (point))
    (unless (= origin end)
      (list origin end))))

(defsubst rfc5322-parse-quoted-string ()
  "Parse RFC 5322 quoted string.

Returned (START END) bounds the quote, including the DQUOTEs."
  (let ((origin (point)) start end)
    (if (and (char= ?\" (char-after))
	     (setq start (point))
	     (progn (forward-char 1) t)
	     (while (or (rfc5322-parse-fws)
			(rfc5322-parse-qcontent)))
	     (char= ?\" (char-after))
	     (progn (forward-char 1) t)
	     (setq end (point)))
	(progn
	  (rfc5322-parse-cfws)
	  (list start end))
      (goto-char origin)
      nil)))

;; RFC 5322 higher-level utilities

(defsubst rfc5322-parse-word ()
  (or (rfc5322-parse-atom)
      (rfc5322-parse-quoted-string)))

(defsubst rfc5322-parse-phrase ()
  (let ((origin (point)) start end val)
    (rfc5322-parse-cfws)
    (setq start (point))
    (while (setq val (rfc5322-parse-word))
      (setq end (nth 1 val)))
    (if end
	(list start end)
      (goto-char origin)
      nil)))

(defsubst rfc5322-parse-unstructured ()
  (let ((start (point)))
    (while (if (rfc5322-parse-fws)
	       (when (= 0 (skip-chars-forward rfc5234-vchar))
		   (error 'invalid-state
			  (format "blank line in field at position %d"
				  (point))))
	     (skip-chars-forward rfc5234-vchar)))
    (skip-chars-forward rfc5234-wsp)
    (list start (point))))

;;; Header field parsing

;;; RFC 2045 Content-Type

(defconst rfc2045-tspecials #r"][()<>@,;:\\\"/?="
  "Same as RFC 2281 tspecials.

Must be in quoted string to use within parameter values.
RFC 2045 does not admit quoted-pairs in Content-Type.")

(defconst rfc2045-token #r"0-9A-Za-z!#$%&'*+-.^_`{|}~"
  "All RFC 5234 VCHARs except tspecials.")

;; #### Abstract these token parsers that just differ in the allowed
;; constituent characters.
;; #### It looks like a good convention is to have tokens parse preceding
;; CFWS but not trailing CFWS.  Higher-level parsers should assume this.
;; No, that's backwards.  It's easier to distinguish error from absence of
;; a syntactically optional token if we always eat up the trailing CFWS.
;; #### Maybe it's an idea to warn on presence of CFWS in most places?
(defsubst rfc2045-parse-token ()
  "Parse a Content-Type token according to RFC 2045."
  (let ((start (point)))
    (skip-chars-forward rfc2045-token)
    (prog1 (list start (point))
      (rfc5322-parse-cfws))))

(defsubst rfc2045-require-separator (sep)
  "Check for separator."
  (unless (char= sep (char-after))
    (error 'invalid-state
	   (format "expected separator %c at %d" sep (point))))
  (forward-char 1)
  (rfc5322-parse-cfws))

(defsubst rfc2045-parse-content-type-parameter ()
  "Parse a parameter in Content-Type.  Returns (KEY VALUE).

See also rfc2045-parse-content-type."
  (let (key value)
    (rfc2045-require-separator ?\;)
    (setq key (apply #'buffer-substring (rfc2045-parse-token)))
    (rfc5322-parse-cfws)
    (rfc2045-require-separator ?=)
    (setq value (apply #'buffer-substring (or (rfc5322-parse-quoted-string)
					      (rfc2045-parse-token))))
    (prog1 (list key value)
      (rfc5322-parse-cfws))))

;; #### #'rfc2045-parse-content-type and #'rfc2183-parse-content-dispostion
;; assume the higher level code determines the field name.  These functions
;; parse only the body.  #### Define helper commands named
;; rfcNUMBER-parse-FIELD-field.
(defsubst rfc2045-parse-content-type ()
  "Parse the Content-Type field body according to RFC 2045.
Return ('content-type ('type TYPE) ('subtype SUBTYPE) (KEY VALUE) ...).
All elements are strings.

#### TYPE, SUBTYPE, and KEYs may become symbols (or keywords).

Note that RFC 2045 uses the RFC 822 definition of structured field.  Thus

    To aid in the creation and reading of structured  fields,  the
    free  insertion   of linear-white-space (which permits folding
    by inclusion of CRLFs)  is  allowed  between  lexical  tokens.
    Rather  than  obscuring  the  syntax  specifications for these
    structured fields with explicit syntax for this  linear-white-
    space, the existence of another \"lexical\" analyzer is assumed.
    This analyzer does not apply  for  unstructured  field  bodies
    that  are  simply  strings  of  text, as described above.  The
    analyzer provides  an  interpretation  of  the  unfolded  text
    composing  the body of the field as a sequence of lexical sym-
    bols.
 
    These symbols are:
 
                 -  individual special characters
                 -  quoted-strings
                 -  domain-literals
                 -  comments
                 -  atoms
 
    The first four of these symbols  are  self-delimiting.   Atoms
    are not; they are delimited by the self-delimiting symbols and
    by  linear-white-space.   For  the  purposes  of  regenerating
    sequences  of  atoms  and quoted-strings, exactly one SPACE is
    assumed to exist, and should be used, between them.  (Also, in
    the \"Clarifications\" section on \"White Space\", below, note the
    rules about treatment of multiple contiguous LWSP-chars.)
    (RFC 822 3.1.4)

and

    Note:  In structured field bodies, multiple linear space ASCII
           characters  (namely  HTABs  and  SPACEs) are treated as
           single spaces and may freely surround any  symbol.   In
           all header fields, the only place in which at least one
           LWSP-char is REQUIRED is at the beginning of  continua-
           tion lines in a folded field.


    Note:  Within systems conforming to this standard, wherever  a
           member of the list of delimiters is allowed, LWSP-chars
           may also occur before and/or after it.
           (RFC 822 3.4.2)

As far as I can tell, all this means that in Content-Type field bodies, CFWS
may appear at the beginning and end of the field, and around the delimiters
'/' and ';'."
  (let ((case-fold-search t) retval keyval)
    (setq retval (list (list 'type (apply #'buffer-substring
					  (rfc2045-parse-token)))))
    (rfc2045-require-separator ?/)
    (setq retval (list (list 'subtype (apply #'buffer-substring
					     (rfc2045-parse-token)))))
    (while (setq keyval (rfc2045-parse-content-type-parameter))
      (nconc retval (list keyval)))
    retval))

;; #### Can this be unified with #'rfc2045-parse-content-type?
(defsubst rfc2183-parse-content-disposition ()
  "Parse the Content-Disposition field according to RFC 2183.
Return ('content-disposition ('type TYPE) (KEY VALUE) ...).
All elements are strings.

#### TYPE, SUBTYPE, and KEYs may become symbols (or keywords).

See #'rfc2045-parse-content-type for treatment of whitespace."
  (let ((case-fold-search t) retval keyval)
    (setq retval
	  (list (list 'type (apply #'buffer-substring (rfc2045-parse-token)))))
    (while (setq keyval (rfc2045-parse-content-type-parameter))
      (nconc retval (list (apply #'buffer-substring keyval))))
    retval))

;; #### This should be sjt/vm-parse-structured-FIELDBODY.
;; #### This probably should be parse-content-type, not parse-structured.
;; #### This probably only works on the assumption that the MIME type in 
;; Content-Type contains no whitespace.
(defun sjt/vm-parse-structured-header (field-body &optional sepchar keep-quotes)
  "Return a list of parameters parsed from FIELD-BODY. #### CHECK RFC 2047!!
Each parameter may be a token or a token=value combination as a single string.
RFC 2047 and RFC 2231 processing is NOT done here.
SEPCHAR is the character separating parameters in the field, default semicolon.
KEEP-QUOTES non-nil means to preserve double quotation marks in the body.
API and semantics are VM-conforming."
  (if (null field-body)
      ()
    ;; #### use with-temp-buffer instead?
    (let ((work-buffer (vm-make-work-buffer)))
      (buffer-disable-undo work-buffer)
      (with-current-buffer work-buffer
       (unwind-protect
	   (let ((list nil)
		 ;; CHANGE: not a regexp, use double \\ not quad \\\\
		 (nonspecials "^\"\\( \t\n\r\f") 
		 start s char sp+sepchar)
	     (if sepchar
		 (setq nonspecials (concat nonspecials (list sepchar))
		       sp+sepchar (concat "\t\f\n\r " (list sepchar))))
	     (insert field-body)
	     (goto-char (point-min))
	     (skip-chars-forward "\t\f\n\r ")
	     (setq start (point))
	     (while (not (eobp))
	       (skip-chars-forward nonspecials)
	       (setq char (char-after))
	       (cond ((null char))
		     ((looking-at "[ \t\n\r\f]")
		      ;; Remove whitespace from parameter.
		      ;; Assumes buffer contains one full field so any CR or
		      ;; LF is part of a CR LF WSP sequence.
		      ;; RFC 2045 accepts the RFC 822 definition of LWSP and
		      ;; assumes a lexer that deletes comments and compresses
		      ;; LWSP to a single space, and allows LWSP around all
		      ;; symbols.  This is not allowed in an RFC 5322 world.
		      (delete-char 1))
		     ((= char ?\\)
		      ;; have escaped character, add to parameter
		      ;; #### should delete the backslash
		      ;; #### not RFC 2045 conformant: quoted-pairs not
		      ;; allowed inside a parameter
		      (forward-char 1)
		      (if (not (eobp))
			  (forward-char 1)))
		     ((and sepchar (= char sepchar))
		      ;; parameter is complete, add to list
		      (setq s (buffer-substring start (point)))
		      (if (or (null (string-match "^[\t\f\n\r ]+$" s))
			      (not (string= s "")))
			  (setq list (cons s list)))
		      ;; skip whitespace and blank or empty parameters
		      (skip-chars-forward sp+sepchar)
		      (setq start (point)))
		     ;; CHANGE: this can't succeed, it's not CFWS.
		     ;; presumably "[ \t\n\r\f]" was meant but already present
		     ;;((looking-at " \t\n\r\f")
		     ;; (skip-chars-forward " \t\n\r\f"))
		     ((= char ?\")
		      ;; have quoted string
		      (let ((done nil))
			(if keep-quotes
			    (forward-char 1)
			  (delete-char 1))
			(while (not done)
			  ;; check for escapes or close quote
			  (if (null (re-search-forward "[\\\\\"]" nil t))
			      ;; #### missing close quote, check RFC
			      (setq done t)
			    (setq char (char-before))
			    (cond ((char-equal char ?\\)
				   ;; escaped character, skip it and continue
				   (delete-char -1)
				   (if (eobp)
				       (setq done t)
				     (forward-char 1)))
				  ;; quote, process keep-quotes
				  (t (if (not keep-quotes)
					 (delete-char -1))
				     (setq done t)))))))
		     ((= char ?\()
		      ;; have comment; find end and delete
		      ;; #### RFC 2045 apparently allows comments based on
		      ;; the RFC 822 "implicit lexer".
		      (let ((done nil)
			    (pos (point))
			    (parens 1))
			(forward-char 1)
			(while (not done)
			  ;; comments nest!
			  (if (null (re-search-forward "[\\\\()]" nil t))
			      ;; #### missing close paren, check RFCs
			      ;; I think this is wrong -- comment requires the
			      ;; close paren, so shouldn't delete
			      (setq done t)
			    (setq char (char-before))
			    ;; CHANGE: using char-equal on punctuation is stupid
			    (cond ((= char ?\\) (if (eobp)
						    (setq done t)
						  (forward-char 1)))
				  ((= char ?\() (setq parens (1+ parens)))
				  (t (setq parens (1- parens)
					   done (zerop parens))))))
			(delete-region pos (point))))))
	     ;; process last parameter
	     (setq s (buffer-substring start (point)))
	     (if (and (null (string-match "^[\t\f\n\r ]+$" s))
		      (not (string= s "")))
		 (setq list (cons s list)))
	     (nreverse list))
	(and work-buffer (kill-buffer work-buffer)))))))

;;; RFC 2231 handling

;; RFC 2231 provides a robust protocol to handle multilingual or
;; multicharset values in the header.  RFC 2047 is frequently used
;; for Japanese in the 'name' parameter of Content-Type, but this
;; is prohibited by the RFC (not sure why).  Pragmatically, long
;; parameter values will need to be split across lines to stay within
;; the mandated 76-character line limit.  Doing this with MIME words
;; is problematic because of less robust treatment by MUAs of FWS.

;; RFC 2231 is specifically for use in parameters in Content-Type and
;; Content-Disposition fields.  Like RFC 2047, RFC 2231 permits
;; arbitrary text to be encoded as multiple RFC 5322 atoms or quoted
;; text that fits within the recommended line length.  (Unlike RFC
;; 2047, RFC 2231 doesn't mandate a maximum line length.)

(defconst sjt/rfc822-specials rfc5322-specials)
(defconst sjt/rfc2231-tspecials "()<>@,;:\\\"/[]?=")
(defconst sjt/rfc2231-aspecials "'*%")
;; Produce 94 ASCII characters not SPACE or CTL (including DEL).
;; (let* ((i #x7f) (attchars nil))
;;   (while (>= i 32)
;;     (decf i))
;;     (setq attchars (cons (int-to-char i) attchars))
;;   (insert (apply #'concat (list attchars))))
(defconst sjt/rfc2231-attribute-characters
  "0-9A-Za-z!#$&+-.^_`{|}~")
(defconst sjt/rfc2231-token-characters
  (concat sjt/rfc2231-attribute-characters sjt/rfc2231-aspecials))
(defconst sjt/broken-token-characters
  (concat sjt/rfc2231-token-characters "?="))
;; Should produce 94.
;; (apply #'+ (mapcar #'length (list sjt/rfc2231-aspecials
;;				  sjt/rfc2231-tspecials
;;				  sjt/rfc2231-attribute-characters)))

;; Used in my version of vm-mime-get-xxx-parameter.
(defun sjt/vm-parse-rfc2231-segment-string (s)
  "Wrapper for sjt/vm-parse-rfc2231-segment."
  (with-temp-buffer
    ;; (message "%S" s)
    (insert s)
    (goto-char (point-min))
    (skip-chars-forward " \t")
    (sjt/vm-parse-rfc2231-segment)))

(defun sjt/vm-parse-rfc2231-segment (&optional end)
  "Parse RFC 2231 segment at point up to END (defaulting to end of line),
returning (NAME NUMBER CHARSET LANG VALUE).  Advance point to end of segment.
NAME, CHARSET, and LANG are strings.  NUMBER is an integer.

SEGMENT := NAME '*=' ENCODED-VALUE
         | NAME '*0=' VALUE
         | NAME '*0*=' [CHARSET] <'> [LANGUAGE] <'> ENCODED-VALUE
         | NAME '*' NUMBER '=' VALUE
         | NAME '*' NUMBER '*=' ENCODED-VALUE

where NAME, CHARSET, and LANGUAGE are tokens, NUMBER is a decimal natural
number, VALUE is a token or quoted string, and ENCODED-VALUE is %-encoded.
In the return value NAME, LANGUAGE, and VALUE are strings, NUMBER is a fixnum,
and CHARSET is a symbol.  VALUE may be encoded but is not delimited by quotes.

It's not clear from RFC 2231 whether in the third form the apostrophes can be
omitted if CHARSET and LANGUAGE are both empty, but parser treats them as
required."
  (interactive (list (point-at-eol)))

  (let (name number charset lang value	; return values
	extendedp start)			; temporary variables

    (labels
	((parse-value (type)
	   (let ((start (point)))
	     (skip-chars-forward type end)
	     (unless (= start (point))
	       (buffer-substring start (point)))))
	 )

      ;; Parse attribute name.
      (skip-chars-forward " \t" end)
      (setq name (or (parse-value sjt/rfc2231-attribute-characters)
		     (error 'args-out-of-range "expected non-empty name")))

      ;; Parse segment information.
      (unless (= ?= (char-after))
	;; check that we got *
	(if (not (= ?* (char-after)))
	    (error 'args-out-of-range "expected ?* or ?= at point")
	  (forward-char 1)		; skip over *
	  ;; look for a sequence number
	  (setq number (parse-value "0-9"))
	  (if (null number)
	      (setq extendedp t)	; no number, but encoded value
	    (when (= ?* (char-after))
	      (setq extendedp t)	; we have an encoded value
	      (forward-char 1))		; skip over *
	    )))

      ;; Parse =.
      (unless (= ?= (char-after))
	;; check that we got =
	(error 'args-out-of-range "expected ?= at point"))
      (forward-char 1)			; skip over =

      ;; Parse charset or language information.
      ;; Charset/lang is allowed only on first segment or only segment.
      (when (and extendedp (or (eql number 0) (eql number nil)))
	(unless (= ?\' (char-after))
	  ;; check that we got '
	  (error 'args-out-of-range "expected ?\' at point"))
	(unless (= start (point))
	  (setq charset (downcase (buffer-substring start (point)))))
	(forward-char 1)			; skip over '
	(setq start (point))
	(skip-chars-forward sjt/rfc2231-attribute-characters)
	(unless (= ?\' (char-after))
	  ;; check that we got '
	  (error 'args-out-of-range "expected ?\' at point"))
	(unless (= start (point))
	  (setq lang (buffer-substring start (point))))
	(forward-char 1)			; skip over '
	)


      ;; Parse value.
      (setq start (point))
      (if extendedp
	  ;; Must not contain a quoted string.
	  (progn (skip-chars-forward sjt/rfc2231-token-characters)
		 (setq value (buffer-substring start (point))))
	;; #### We don't get quoted strings from VM,
	;; and it might contain MIME-words and newlines. :-(
	(setq value (buffer-substring start))
	(when ; (and 
	       (search-forward "=?" nil t)
		  ; (y-or-n-p (format "Decode MIME words: %s " value)))
	  (vm-decode-mime-encoded-words start)
	  (setq value (buffer-substring start))))

      ;; Return list of parsed items.
  ;     (message "%S" (list name number charset lang
  ; 			(substring value 0 (min (length value) 40))))
      (list name number charset lang value))))

(defun sjt/decode-rfc2231-token (start end coding)
  (interactive "r\nzCoding system: ")
  (while (re-search-forward "%\\([0-9A-Fa-f][0-9A-Fa-f]\\)" nil t)
    (goto-char (match-end 0))
    (insert (int-to-char (string-to-number (match-string 1) 16)))
    (delete-region (match-beginning 0) (match-end 0)))
  (decode-coding-region (point) (point-max) coding))

(defconst sjt/parse-rfc2231-filename-parameter-re
   (concat #r"\(filename\*\)"		; 1 "filename*"
	   #r"\(?:\([0-9]+\)\*\)?="	; 2 ordinal
	   ;; #### Optional "'" is not right.
	   #r"\(?:\([^']*\)'\)?"	; 3 encoding
	   #r"\(?:\([^']*\)'\)?"	; 4 language
	   #r"\([^ ;]*\);?"		; 5 text
	   ))

(defun sjt/test-parse-rfc2231-filename-parameter-re ()
  (interactive)
  (back-to-indentation)
  (save-match-data
    (looking-at sjt/parse-rfc2231-filename-parameter-re)
    (list (match-string 1)
	  (match-string 2)
	  (match-string 3)
	  (match-string 4)
	  (match-string 5))))

(defun sjt/forward-header-field (&optional count buffer)
  "Move forward COUNT \(default 1\) header fields in BUFFER \(default current\).
If negative, move backward.  Return t if COUNT fields were moved, else nil.
The header field includes the trailing newline if any.  Does not change mark."
  (interactive "pi")
  ;; #### Should save-excursion here?
  (set-buffer (or buffer (current-buffer)))
  (setq count (or count 1))

  (labels
      ((bohp ()
	 ;; beginning-of-header-p
	 ;; #### Close enough as long as we count From as part of the header.
	 (or (bobp)
	     (save-excursion
	       (forward-line -1)
	       (and (eolp) (bolp)))))
       (eohp ()
	 ;; end-of-header-p
	 (or (eobp)
	     (and (eolp) (bolp))))
       (bohfp ()
	 ;; beginning-of-header-field-p
	 (looking-at "^[A-Za-z]"))	; #### Not RFC-ly correct.
       (hfbp ()
	 ;; header-field-boundary-p
	 ;; Same as end-of-header-field-p except at the beginning of header.
	 ;; beginning of header is annoying to check in mbox.
	 (or (eohp) (bohfp))))
    (let ((direction (signum count))
	  (count (abs count))
	  (pt (point))
	  (done nil))
      ;; Move once to handle middle of line case.
      (cond ((< direction 0) (beginning-of-line))
	    ((> direction 0) (forward-line 1)))
      ;; If we moved and we're at a boundary, count it.
      (when (and (= pt (point)) (hfbp))
	(decf count))
      ;; Do remaining movement.
      (while (and (> count 0) (not done))
	(setq pt (point))
	(while (not (hfbp))
	  (forward-line direction))
	(unless (= pt (point))
	  (decf count))
	(when (or (and (< direction 0) (bohp))
		  (and (> direction 0) (eohp)))
	  (setq done t))))))
    

(defun sjt/mark-header-field (&optional count)
  "Mark the text from point until encountering the end of a header field.
With optional argument COUNT, mark COUNT fields.  COUNT negative means to
mark backwards."
  (interactive "p")
  (mark-something 'sjt/mark-header-field 'sjt/forward-header-field count))


(defun sjt/check-field (field-name-re)
  (interactive "sField name regexp: ")
  (unless (looking-at (concat #r"^\(" field-name-re #r"\)\s-*:"))
    (error 'args-out-of-range (format "not looking-at %s" field-name-re))))


;; #### Should use #'sjt/vm-parse-rfc2231-segment.
(defun sjt/vm-get-filename-from-content-disposition ()
  (interactive)
  (let ((case-fold-search t)
	(value nil)
	(encoding nil)
	(parameters nil)
	(parameter nil)
	(start nil))
    (save-match-data
      (sjt/check-field "content-disposition")
      (goto-char (match-end 0))
      (setq parameters
	    (sjt/vm-parse-structured-header (buffer-substring
					     (point)
					     (save-excursion
					       (sjt/forward-header-field 1)
					       (point)))
					    ?\; t))
      (setq parameters (delete-if
			(lambda (x)
			  (not (string-match "^filename" x)))
			parameters))
      (setq parameters (stable-sort parameters #'string<))
      (setq value "")
      (setq start 0)
      (while parameters
	(setq parameter (pop parameters))
	(string-match sjt/parse-rfc2231-filename-parameter-re parameter)
	(let ((filename (match-string 1 parameter))
	      (ordinal (match-string 2 parameter))
	      (enc (match-string 3 parameter))
	      (language (match-string 4 parameter))
	      (text (match-string 5 parameter)))
	  (setq ordinal (if ordinal (string-to-number ordinal) 0))
	  (when enc (setq enc (intern (downcase enc))))
	  (when language (setq language (downcase language)))
	  (when (not (string= filename "filename*"))
	    (error 'args-out-of-range "not a filename parameter" filename))
	  (unless (= start ordinal)
	    (error 'args-out-of-range "missing filename parameter" start))
	  (if (= start 0)
	      (setq encoding enc)
	    (when (or enc language)
	      (error 'args-out-of-range "encoding or language after start"
		     enc language)))
	  (setq value (concat value text))
	  (incf start))))
    ;; #### should use parse-rfc2231-token
    (with-temp-buffer
      (insert value)
      (goto-char (point-min))
      (while (not (eobp))
	(if (not (equal (char-after) ?%))
	    (forward-char 1)
	  (delete-char 1)
	  (insert (int-to-char
		   (string-to-number (buffer-substring (point) (+ (point) 2))
				     16)))
	  (delete-char 2)))
      (decode-coding-region (point-min) (point-max) encoding)
      (setq value (buffer-substring)))
    (message "%s" value)
    value))


;;; Monkey-patch VM stuff

(defun vm-mime-get-xxx-parameter-version-1 (name param-list)
  "Return the parameter NAME from PARAM-LIST.

If parameter value continuations was used, i.e. the parameter was split into
shorter pieces, rebuild it from them."
  ;; (message "Retrieving parameter %s at %s in %s"
  ;;          name (point) (current-buffer))
  (let ((parsed-parameters (mapcar #'sjt/vm-parse-rfc2231-segment-string
				   param-list))
	(count -1)
	parsed-parameter charset value-charset can-display need-conversion
	start number value)
    (setq parsed-parameters (delete-if (lambda (x) (not (string= x name)))
				       parsed-parameters
				       :key #'first))
    ;; The test here is to return nil, not the empty string, if there are
    ;; parameters left.
    (when parsed-parameters
      (setq parsed-parameters (sort* parsed-parameters #'< :key #'second))
      (with-temp-buffer
	(setq start (point-min))
	(while parsed-parameters
	  (setq parsed-parameter (pop parsed-parameters)
		number (second parsed-parameter)
		charset (third parsed-parameter)
		;; Ignore language.
		value (fifth parsed-parameter)
		count (1+ count))
; 	  (message "%s" (if (null number)
; 			    "only segment"
; 			  (format "segment %d" number)))

	  ;; error-checking, and determine if we can decode the charset and
	  ;; how to do so
	  (cond ((and (= count 0) (null number)))
		((eql count number))
		(t (error 'args-out-of-range "expected segment" count
			  "but got" number)))
	  (when (and (= count 0) (setq value-charset charset))
	    (setq can-display
		  (vm-mime-charset-internally-displayable-p value-charset))
	    (unless can-display
	      (setq need-conversion
		    (vm-mime-can-convert-charset value-charset))))
; 	  (message "%S %S" value-charset parsed-parameter)
; 	  (sit-for 1)

	  ;; insert the value at the end of the buffer
	  (insert value)

	  ;; decode octets if needed
	  (when charset
	    (goto-char start)
	    (while (re-search-forward "%\\([0-9A-Fa-f][0-9A-Fa-f]\\)" nil t)
	      (goto-char (match-end 0))
	      (insert (int-to-char (string-to-number (match-string 1) 16)))
	      (delete-region (match-beginning 0) (match-end 0))))

	  ;; go to end of buffer and reset start
	  (goto-char (point-max))
	  (setq start (point)))
	(if (and (not can-display) need-conversion)
	    (setq charset (vm-mime-charset-convert-region
			   value-charset (point-min) (point-max)))
	  (setq charset value-charset))
	(when (or can-display need-conversion)
	  (vm-mime-charset-decode-region charset (point-min) (point-max)))
;  	(unless (y-or-n-p (format "Return %S " (buffer-substring)))
;  	  (error 'invalid-argument "Something's wrong."))
	(buffer-substring)))))

;; #### This function is UNCHANGED from vm-mime.el version.
;; #### Instead of (string-match name-regexp ...), probably faster is
;; (and (string= name (substring ...)) (= ?= (aref ... (length name)))).
; (defun vm-mime-get-xxx-parameter-internal (name param-list)
;   "Return the parameter NAME from PARAM-LIST."
;   (let ((match-end (1+ (length name)))
; 	(name-regexp (concat (regexp-quote name) "="))
; 	(case-fold-search t)
; 	(done nil))
;     (while (and param-list (not done))
;       (if (and (string-match name-regexp (car param-list))
; 	       (= (match-end 0) match-end))
; 	  (setq done t)
; 	(setq param-list (cdr param-list))))
;     (and (car param-list)
; 	 (substring (car param-list) match-end))))

;; CHANGES:
;; (1) Don't use #'vm-mime-get-xxx-parameter-internal.
;; (2) Handle charset processing (#### ignore language).
;; #### Doesn't work with rawstrings because "\\n" doesn't match newline?
(defconst param-re-fmt
  (concat "\\`%s"			; parameter name goes here
	  "\\(?:\\*\\([0-9]+\\)\\)?"	; if 1 is digits, multiple segments
	  "\\(\\*\\)?"			; if 2 is *, parameter encoded
	  "=\\(\\(?:\n\\|.\\)*\\)\\'"	; 3 is maybe encoded value
					; #### folding not allowed by RFC
	  ))
(defun vm-mime-get-xxx-parameter-version-2 (name param-list)
  "Return the parameter NAME from PARAM-LIST.

If parameter value continuations was used, i.e. the parameter was split into
shorter pieces, rebuild it from them."
  (let ((param-re (format param-re-fmt (regexp-quote name)))
	param charset lang)
    ;; convert param-list from "name=value" to (ORDER ENCODED-TEXT FLAG)
    ;; and remove non-matching parameters
    (setq param-list (delete-if #'null
				(mapcar
				 (lambda (s)
				   (when (string-match param-re s)
				     (list (and (match-string 1 s)
						(string-to-number
						 (match-string 1 s)))
					   (match-string 3 s)
					   (match-string 2 s))))
				 ;; #### use remove-if to avoid this?
				 (copy-sequence param-list))))
    (if (= 1 (length param-list))
	(and (setq param (car param-list))
	     ;; If FLAG is true, RFC 2231-encoded.
	     (if (third param)
		 (first (vm-decode-encoded-segment (second param) t))
	       ;; Otherwise, handle possible MIME-encoding.
	       (vm-decode-mime-encoded-words-in-string (second param))))
      (setq param-list (sort* param-list #'< :key #'car)
	    param (car param-list))
      (if (not (third param))		; As above.
	  ;; #### An abomination, probably should restrict to Content-Type.
	  (when param
	    (mapconcat (lambda (x)
			 (vm-decode-mime-encoded-words-in-string (second x)))
		       param-list
		       ""))
	(setq param (vm-decode-encoded-segment (second param) t)
	      charset (second param)
	      lang (third param)
	      param (first param)
	      param-list (cdr param-list))
	(apply #'concat
	       (cons param
		     (mapcar (lambda (x)
			       ;; Funky RFC 2231 stuff: when first segment
			       ;; is encoded, trailing segments may or may
			       ;; not be encoded.  Need to check each.
			       (if (third x)
				   (car (vm-decode-encoded-segment
					 (second x) charset lang))
				 (second x)))
			     param-list)))))))

(fset 'vm-mime-get-xxx-parameter 'vm-mime-get-xxx-parameter-version-2)

(defun vm-decode-encoded-segment (segment &optional charset lang)
  "Return (TEXT CHARSET LANG) of a parameter SEGMENT decoded per RFC 2231.

SEGMENT is the string to decode.
If CHARSET is t, this is the first encoded segment.
Otherwise, CHARSET and LANG should symbols returned by this function."
  (when (eq charset t)
    (setq segment (split-string segment "'")
	  charset (downcase (first segment))
	  charset (if (string= charset "us-ascii") "" charset)
	  charset (and (> (length charset) 0) (intern charset))
	  lang (downcase (second segment))
	  lang (and (> (length lang) 0) (intern lang))
	  segment (third segment)))
  (with-temp-buffer
    (insert segment)
    (goto-char (point-min))
    (skip-chars-forward "^%")
    (while (not (eobp))
      (delete-char 1)
      (insert (int-to-char
	       (string-to-number (buffer-substring (point) (+ (point) 2))
				 16)))
      (delete-char 2)
      (skip-chars-forward "^%"))
    (decode-coding-region (point-min) (point-max) charset)
    (list (buffer-string) charset lang)))


;; #### This function is UNCHANGED from vm-mime.el version.
; (defun vm-mime-get-parameter (layout param)
;   (let ((string (vm-mime-get-xxx-parameter 
; 		 param (cdr (vm-mm-layout-type layout)))))
;     (if string (vm-decode-mime-encoded-words-in-string string))))

;; #### This function is UNCHANGED from vm-mime.el version.
; (defun vm-mime-get-disposition-parameter (layout param)
;   (let ((string (vm-mime-get-xxx-parameter 
; 		 param (cdr (vm-mm-layout-disposition layout)))))
;     (if string (vm-decode-mime-encoded-words-in-string string))))

; CHANGE: use rawstring notation.  Not worth monkey-patching.
;(defconst vm-mime-encoded-word-regexp
;  #r"=\?\([^?*]+\)\(\*\([^?*]+\)\)?\?\([BbQq]\)\?\([^?]+\)\?=")
;; #### This function is UNCHANGED from vm-mime.el version.
; (defun vm-decode-mime-encoded-words ()
;   (let ((case-fold-search t)
; 	(buffer-read-only nil)
; 	charset need-conversion encoding match-start match-end start end)
;     (save-excursion
;       (goto-char (point-min))
;       (while (re-search-forward vm-mime-encoded-word-regexp nil t)
; 	(setq match-start (match-beginning 0)
; 	      match-end (match-end 0)
; 	      charset (buffer-substring (match-beginning 1) (match-end 1))
;               need-conversion nil
; 	      encoding (buffer-substring (match-beginning 4) (match-end 4))
; 	      start (match-beginning 5)
; 	      end (vm-marker (match-end 5)))
; 	;; don't change anything if we can't display the
; 	;; character set properly.
; 	(if (and (not (vm-mime-charset-internally-displayable-p charset))
; 		 (not (setq need-conversion
; 			    (vm-mime-can-convert-charset charset))))
; 	    nil
; 	  (delete-region end match-end)
; 	  (condition-case data
; 	      (cond ((string-match "B" encoding)
; 		     (vm-mime-B-decode-region start end))
; 		    ((string-match "Q" encoding)
; 		     (vm-mime-Q-decode-region start end))
; 		    (t (vm-mime-error "unknown encoded word encoding, %s"
; 				      encoding)))
; 	    (vm-mime-error (apply 'message (cdr data))
; 			   (goto-char start)
; 			   (insert "**invalid encoded word**")
; 			   (delete-region (point) end)))
; 	  (and need-conversion
; 	       (setq charset (vm-mime-charset-convert-region
; 			      charset start end)))
; 	  (vm-mime-charset-decode-region charset start end)
; 	  (goto-char end)
; 	  (delete-region match-start start))))))

;; based on vm-mime-operate-on-attachments
(defun* vm-mime-operate-on-parts (count &key 
				  ((:name action-name))
				  ((:action action))
				  ((:included types)) 
				  ((:excluded exceptions))
				  ((:messages mlist)))
  "On the next COUNT messages or marked messages, call the
function ACTION on all \"parts\".  

IRRELEVANT?  If so, nuke the corresponding arguments.
  For the purpose of this function, an \"attachment\" is a mime
  part part which has \"attachment\" as its disposition, or simply
  has an associated filename, or has a type that matches a regexp
  in TYPES but doesn't match one in EXCEPTIONS.

ACTION-NAME should be a human-readable string describing the
action in minibuffer messages.  Or it can be nil to suppress
messages. 

ACTION will get called with four arguments: MSG LAYOUT TYPE FILENAME." 
  (unless mlist
    (unless count (setq count 1))
    (vm-check-for-killed-folder)
    (vm-select-folder-buffer-and-validate 1 nil))

  (let ((mlist (or mlist (vm-select-operable-messages
			  count (vm-interactive-p) "Action on"))))
    (vm-retrieve-operable-messages count mlist :fail t)
    (save-excursion
      (while mlist
        (let (m parts layout filename type disposition o)
          (setq o (vm-mm-layout (car mlist)))
          (when (stringp o)
            (setq o 'none)
            (backtrace)
            (vm-inform 0 "There is a bug, please report it with *backtrace*"))
          (unless (eq o 'none)
            (setq type (car (vm-mm-layout-type o)))
            
            (cond ((or (vm-mime-types-match "multipart" type)
                       (vm-mime-types-match "message" type)
                       )
                   (setq parts (copy-sequence (vm-mm-layout-parts o))))
                  (t (setq parts (list o))))
            
            (while parts
              (while (vm-mime-composite-type-p
		      (car (vm-mm-layout-type (car parts))))
		(setq parts 
		      (nconc (copy-sequence (vm-mm-layout-parts (car parts)))
			     (cdr parts))))
              
              (setq layout (car parts)
                    type (car (vm-mm-layout-type layout))
                    disposition (car (vm-mm-layout-disposition layout))
                    filename (vm-mime-get-disposition-filename layout) )
              
	      (when action-name
		(vm-inform 10
			   "%s part type=%s filename=%s disposition=%s"
			   action-name type filename disposition))
	      (funcall action (car mlist) layout type filename))
              (setq parts (cdr parts)))))
        (setq mlist (cdr mlist)))))

;; From vm-mime.el.
;; Lots of bad coding here. :-(
;; CHANGES:
;; (1) Descend into nested composite parts.
;; (2) Handle Content-Disposition "filename" and Content-Type "name" attributes
;;     correctly.
(defun vm-mime-action-on-all-attachments (count action
                                                &optional include exclude
                                                mlist
                                                quiet)
  "On the next COUNT or marked messages or messages in MLIST, call the function
ACTION on those mime parts which have a filename or the disposition attachment
or match with their type to INCLUDE but not to EXCLUDE (which are lists of MIME
types).

If QUIET is true no messages are generated.

ACTION will get called with four arguments: MSG LAYOUT TYPE FILENAME." 
  (unless mlist
    (or count (setq count 1))
    (vm-check-for-killed-folder)
    (vm-select-folder-buffer)
    (vm-error-if-folder-empty))

  ;; #'vm-select-marked-or-prefixed-messages is from vm-folder.el.
  (let ((mlist (or mlist (vm-select-marked-or-prefixed-messages count))))
    (save-excursion
      (while mlist
        (let (parts layout filename type disposition o)
          (setq o (vm-mm-layout (car mlist)))
	  ;; #### Can this happen?  How?
          (when (stringp o)
            (setq o 'none)
	    ;; #### Is this actually used?
            (backtrace (get-buffer-create "*backtrace*"))
            (message "There is a bug, see *backtrace* for details"))
          (if (eq 'none o)
              nil;; this is no mime message
            (setq type (car (vm-mm-layout-type o)))
            
            (cond ((or (vm-mime-types-match "multipart/alternative" type)
                       (vm-mime-types-match "multipart/mixed" type)
                       (vm-mime-types-match "multipart/report" type)
                       (vm-mime-types-match "message/rfc822" type)
                       )
                   (setq parts (copy-sequence (vm-mm-layout-parts o))))
                  (t (setq parts (list o))))
            
            (while parts
	      ;; CHANGE: reiterate if we've descended into a nested part.
	      ;; In vm-rfaddons, this if has only the true branch.
	      ;; That means that we don't visit nested composite parts.
              (if (vm-mime-composite-type-p
                   (car (vm-mm-layout-type (car parts))))
                  (setq parts (nconc (copy-sequence
                                      (vm-mm-layout-parts
                                       (car parts)))
                                     (cdr parts)))
              
		(setq layout (car parts)
		      type (car (vm-mm-layout-type layout))
		      disposition (car (vm-mm-layout-disposition layout))
		      ;; Somewhat redundant with processing in
		      ;; #'vm-send-mime-body-to-file.
		      ;; CHANGE: vm-rfaddons.el checks for "filename*", but
		      ;; #'vm-mime-get-*parameter does that.  vm-rfaddons.el
		      ;; doesn't check for Content-Type "name" parameter.
		      filename (or
				(vm-mime-get-disposition-parameter layout
								   "filename")
				(vm-mime-get-parameter layout "name")
				;; #### nonconformant to RFC 2184/2231.
				;; Following vm-rfaddons.el here.
				;; Does this even happen?
				(vm-mime-get-disposition-parameter layout
								   "name")))
              
		(cond ((or filename
			   (and disposition (string= disposition "attachment"))
			   (and (not (vm-mime-types-match
				      "message/external-body"
				      type))
				include
				(vm-mime-is-type-valid type include exclude)))
		       (when (not quiet)
			 (message
			  "Action on part type=%s filename=%s disposition=%s!"
			  type filename disposition))
		       (funcall action (car mlist) layout type filename))
		      ((not quiet)
		       (message
			"No action on part type=%s filename=%s disposition=%s!"
			type filename disposition)))
		(setq parts (cdr parts))))))
	(setq mlist (cdr mlist))))))

;;; Tests

(defun rfc2231-test-parse-field (field name)
  (let ((parameters (sjt/vm-parse-structured-header
		     (substring field
				(1+ (string-match ":" field)))
		     ?\;)))
    (list parameters
	  (format param-re-fmt (regexp-quote name))
	  ;(vm-mime-get-xxx-parameter-version-1 name parameters)
	  (rfc2231-test-filter-param-list name parameters)
	  (vm-mime-get-xxx-parameter-version-2 name parameters)
	  )))

(defun rfc2231-test-filter-param-list (name params)
  (let ((param-re (format param-re-fmt (regexp-quote name))))
    (delete-if #'null
	       (mapcar (lambda (s)
			 (when (string-match param-re s)
			   (list (and (match-string 1 s)
				      (string-to-number
				       (match-string 1 s)))
				 (match-string 3 s)
				 (match-string 2 s))))
		       ;; #### is copy-sequence needed?
		       (copy-sequence params)))))

(defconst rfc2231-test-fields '(
"Content-Type: message/external-body; access-type=URL;\r
 URL*0=\"ftp://\";\r
 URL*1=\"cs.utk.edu/pub/moore/bulk-mailer/bulk-mailer.tar\"\r
"
"Content-Type: application/x-stuff;\r
 title*=us-ascii'en-us'This%20is%20%2A%2A%2Afun%2A%2A%2A\r
"
"Content-Type: application/x-stuff;\r
    title*0*=us-ascii'en'This%20is%20even%20more%20;\r
    title*1*=%2A%2A%2Afun%2A%2A%2A%20;\r
    title*2=\"isn't it!\"\r
"
"Content-Type: application/x-stuff;\r
    title*1*=%2A%2A%2Afun%2A%2A%2A%20;\r
    title*2=\"isn't it!\";\r
    title*0*=us-ascii'en'This%20is%20even%20more%20\r
"
)
  "These come from the RFC.")

(defconst nonconformant-test-fields '(
"Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document;\r
	name=\"=?UTF-8?B?44OG44Kt44K544OI44Oe44Kk44OL44Oz44Kw44KS55So44GE44Gf5YyW57Kn5ZOB6LO86LK344Gr?=\r
	=?UTF-8?B?44GK44GR44KLLmRvY3g=?=\"\r
"
"Content-Disposition: attachment;\r
	filename=\"=?UTF-8?B?44OG44Kt44K544OI44Oe44Kk44OL44Oz44Kw44KS55So44GE44Gf5YyW57Kn5ZOB6LO86LK344Gr?=\r
	=?UTF-8?B?44GK44GR44KLLmRvY3g=?=\"\r
"
)
  "These come from mail from 伊藤悠斗.")

(defun fujikawa-test-get-xxx-parameter ()
  (save-excursion
    (set-buffer "INBOX Summary")
    (let* ((msg (vm-current-message))
	   (layout (vm-mm-layout msg))
	   (parts (vm-mm-layout-parts layout))
	   (ma-part (second parts)) 	; multipart/alternative for Apple Mail
					; from Fujikawa
	   )
      (loop
	for part in (vm-mm-layout-parts ma-part)
	collect
	;(vm-mm-layout-type part)
	(vm-mime-get-xxx-parameter "filename"
	  (vm-mm-layout-disposition part)
	  )
        ;(vmn-mm-layout-parts part)
	)
      )))

(defun test-vm-mime-types-match (&optional report-successes)
  (interactive "P")
  (let ((results nil))
    (labels ((test (type type/subtype expected-result)
	       (let ((result (vm-mime-types-match type type/subtype)))
		 (when (or report-successes
			   (not (eq (null result) (null expected-result))))
		   (push (list type type/subtype
			       'expected (if expected-result 'success 'fail)
			       (if result 'success 'fail))
			 results)))))
      (test "text/plain" "image/png" nil)
      (test "text/plain" "text" nil)
      (test "text" "text/plain" t)
      (test "text/" "text/plain" nil)
      (test "text/plain" "text/plain" t)
      (test "text" "textplain" nil))
    (message "%s" results)
    results))

(defun test-buffer-default-directory ()
  (interactive)
  (save-excursion
    (let ((buf1 (save-excursion
		  (find-file
		   "/Users/steve/edu/schedule.txt")
		  (current-buffer)))
	  (buf2 (save-excursion
		  (find-file "/Users/steve/.vm")
		  (current-buffer))))
      (set-buffer buf1)
      (message "%s is %s in %s" "buf1" buf1 default-directory)
      (sit-for 1)
      (set-buffer buf2)
      (message "%s is %s in %s" "buf2" buf2 default-directory)
      )))

